const uuid = require("uuid");
const cds = require("@sap/cds");
const { default: didYouMean, ReturnTypeEnums } = require("didyoumean2");

function calcDurationInH({ start, end }) {
  const durationInMS = new Date(end) - new Date(start);
  const durationInH = durationInMS / 1000 / 60 / 60;
  const durationInHRounded = durationInH.toFixed(2);
  return durationInHRounded;
}

function calcDates(activatedDate, completedDate) {
  const aDate = new Date(activatedDate);
  const cDate = new Date(completedDate);
  return {
    activatedDateMonth: aDate.getUTCMonth() + 1,
    activatedDateYear: aDate.getUTCFullYear(),
    activatedDateDay: aDate.getUTCDate(),
    completedDateMonth: cDate.getUTCMonth() + 1,
    completedDateYear: cDate.getUTCFullYear(),
    completedDateDay: cDate.getUTCDate(),
  };
}

function categorizeWorkItem(workItem, categories) {
  let category = {};

  if (workItem.parent_ID) {
    // the view for "myCategories" is deployed directly via SQL (not generated by CDS). Somehow the query is in lowercase => use "id" instead of "ID"
    category = categories.find(({ ID }) => ID === workItem.parent_ID);
  } else if (workItem.parentPath) {
    const parentCategoriesTitles = workItem.parentPath.split(" > ");
    parentCategoriesTitles.splice(parentCategoriesTitles.length - 1, 1);
    const parentPathOfParentCategorie = parentCategoriesTitles.join(" > ");

    category = categories.find(
      ({ path }) => path === parentPathOfParentCategorie
    );
  } else if (workItem.title) {
    // const tags = appointment.tags.map(({ tag_title }) => tag_title);

    const titleSubstrings = workItem.title.split(" ");

    const categoriesByReference = categories.filter(
      ({ absoluteReference }) =>
        absoluteReference &&
        titleSubstrings.some((sub) => sub === absoluteReference)
    );

    if (categoriesByReference.length > 0) {
      [category] = categoriesByReference;
    } else {
      const allSortedMatches = didYouMean(
        workItem.title,
        categories
          .filter((cat) => cat && cat.path)
          .map((cat) => cat.path.replaceAll(" > ", " ")),
        { threshold: 0.4, returnType: ReturnTypeEnums.ALL_SORTED_MATCHES }
      );

      const [bestMatch] = allSortedMatches;

      if (bestMatch) {
        category = categories.find(
          (cat) =>
            cat && cat.path && cat.path.replaceAll(" > ", " ") === bestMatch
        );
      } else category = {};
    }
  } else category = {};

  return category;
}

// eslint-disable-next-line func-names
module.exports = cds.service.impl(async function () {
  const db = await cds.connect.to("db");
  const MSGraphSrv = await cds.connect.to("MSGraphService");
  const catService = await cds.connect.to("CategoriesService");
  const { Users, WorkItems } = db.entities("iot.planner");
  const { MyWorkItems } = this.entities();
  // const { MyWorkItems } = this.entities();

  this.on("CREATE", MyWorkItems, async (req, next) => {
    // Create a V4 UUID (=> https://github.com/uuidjs/uuid#uuidv5name-namespace-buffer-offset)
    req.data.ID = uuid.v4();
    req.data.source = "Manual";
    req.data.confirmed = true;
    req.data.duration = calcDurationInH({
      start: req.data.activatedDate,
      end: req.data.completedDate,
    });
    req.data.assignedTo_userPrincipalName = req.user.id;
    req.data.tenant = req.user.tenant;

    const categories = await catService.send("getMyCategoryTree", req.data);
    req.data.parent_ID = categorizeWorkItem(req.data, categories).ID;

    const dates = calcDates(req.data.activatedDate, req.data.completedDate);
    Object.assign(req.data, dates);

    return next();
  });

  this.on("READ", "MyUser", async (req) => {
    const tx = this.transaction(req);
    const details = await tx.run(
      SELECT.from(Users).where({ userPrincipalName: req.user.id })
    );

    return details;
  });

  this.on("READ", "MSGraphWorkItems", async (req) => MSGraphSrv.run(req.query));

  this.on("getMyCategoryTree", async (req) => {
    const categories = await catService.send("getMyCategoryTree", req.data);

    return categories;
  });

  this.on("getMyCustomers", async (req) => {
    const customers = await catService.send("getMyCustomers", req.data);

    return customers;
  });

  this.on("getMyProjects", async (req) => {
    const projects = await catService.send("getMyProjects", req.data);

    return projects;
  });

  this.on("getMySubprojects", async (req) => {
    const subprojects = await catService.send("getMySubprojects", req.data);

    return subprojects;
  });

  this.on("getMyWorkPackages", async (req) => {
    const workPackages = await catService.send("getMyWorkPackages", req.data);

    return workPackages;
  });

  this.on("getWorkItemByID", async (req) => {
    const {
      data: { ID },
    } = req;
    const [MSGraphEvent, [localWorkItem]] = await Promise.all([
      MSGraphSrv.send("getWorkItemByID", { ID }),
      this.run(SELECT.from(MyWorkItems).where({ ID })),
    ]);

    const parent = await catService.run(
      SELECT.from("Categories").where({ ID: localWorkItem.parent_ID })
    );

    const workItem = {
      ...MSGraphEvent,
      ...localWorkItem,
      parent,
      duration: calcDurationInH({
        start: MSGraphEvent.activatedDate,
        end: MSGraphEvent.completedDate,
      }),
      state: "incompleted",
    };

    return workItem;
  });

  this.on("getCalendarView", async (req) => {
    const {
      data: { startDateTime, endDateTime },
    } = req;

    const [MSGraphEvents, localWorkItems, myCategories] = await Promise.all([
      MSGraphSrv.send("getCalendarView", req.data),
      this.run(
        SELECT.from(MyWorkItems).where(
          `activatedDate >= '${startDateTime}' and completedDate <= '${endDateTime}'`
        )
      ),
      catService.send("getMyCategoryTree", req.data),
    ]);

    // Reihenfolge ist wichtig (bei gleicher ID wird erstes mit letzterem überschrieben)
    // TODO: Durch explizite Sortierung absichern.
    const combined = [
      ...MSGraphEvents.map((itm) => ({
        ...itm,
        duration: calcDurationInH({
          start: itm.activatedDate,
          end: itm.completedDate,
        }),
        confirmed: false,
        state: "incompleted",
      })),
      ...localWorkItems.map((itm) => ({ ...itm, confirmed: true })),
    ]
      .filter((itm) => itm)
      /*
      Nur Items mit ID und completedDate übernehmen
      => Verhindert, dass lokale Ergänzungen geladen werden, die in MSGraph oder DevOps gelöscht wurden
      */
      .filter(({ ID, completedDate }) => !!ID && !!completedDate);

    const map = {};

    // eslint-disable-next-line no-restricted-syntax
    for (const appointment of combined) {
      map[appointment.ID] = {
        ...appointment,
      };
    }

    const results = Object.values(map)
      .filter(({ deleted }) => !deleted)
      .map((workItem) => {
        const parent = categorizeWorkItem(workItem, myCategories);

        return {
          ...workItem,
          parent,
        };
      });

    results.$count = results.length;
    return results;
  });

  this.on("UPDATE", MyWorkItems, async (req) => {
    const item = req.data;
    const tx = this.transaction(req);

    item.confirmed = true;
    item.tenant = req.user.tenant;
    item.assignedTo_userPrincipalName = req.user.id;

    if (item.activatedDate && item.completedDate) {
      item.duration = calcDurationInH({
        start: item.activatedDate,
        end: item.completedDate,
      });

      const dates = calcDates(item.activatedDate, item.completedDate);
      Object.assign(item, dates);
    }

    delete item.tags;

    const [entry] = await db.read(WorkItems).where({ ID: item.ID });

    if (entry) {
      await tx.run(UPDATE(WorkItems, item.ID).with(item));
      return item;
    }

    await tx.run(INSERT.into(WorkItems).entries(item));
    return item;
  });

  this.on("resetToDraft", async (req) => {
    const {
      data: { ID },
    } = req;

    const [item] = await db.read(MyWorkItems).where({ ID });

    if (!item) throw Error("Item not found");
    if (item.source === "Manual")
      throw Error("Reset is only for items from 3rd party sources.");

    const [draft, myCategories] = await Promise.all([
      MSGraphSrv.send("getWorkItemByID", { ID }),
      catService.send("getMyCategoryTree", req.data),
      db.run(DELETE.from(MyWorkItems).where({ ID })),
    ]);

    const parent = categorizeWorkItem(draft, myCategories);

    draft.parent = parent;
    draft.parentPath = parent.path;

    return draft;
  });

  this.on("removeDraft", async (req) => {
    const {
      data: { ID, activatedDate, completedDate },
      user,
    } = req;

    await db.run(DELETE.from(MyWorkItems).where({ ID }));
    await db.run(
      INSERT.into(MyWorkItems).entries({
        ID,
        tenant: user.tenant,
        deleted: true,
        assignedTo_userPrincipalName: user.id,
        activatedDate,
        completedDate,
      })
    );
  });
});
